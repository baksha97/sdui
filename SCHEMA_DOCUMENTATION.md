# SDUI Schema Documentation

This document provides comprehensive documentation for all schemas used in the Server-Driven UI (SDUI) framework.

## Overview

The SDUI system uses multiple schema layers to ensure type safety, validation, and consistency across different components:

1. **Protocol Buffer Schema** - Core token definitions for serialization
2. **Kotlin Data Models** - Type-safe data classes for runtime use
3. **DSL Builder Schema** - Fluent API for programmatic UI construction
4. **JSON Schema** - Validation schema for external integrations
5. **Component Registration Schema** - Annotation-based component management

## Schema Layers

### 1. Protocol Buffer Schema (`schema/sdui.proto`)

The foundational schema defining all SDUI tokens and supporting types.

**Location**: `schema/sdui.proto`

**Key Components**:
- `Token` - Base message with oneof for all token types
- Container tokens: `ColumnToken`, `RowToken`, `BoxToken`, `LazyColumnToken`, `LazyRowToken`, `CardToken`
- Leaf tokens: `TextToken`, `ButtonToken`, `SpacerToken`, `DividerToken`, `SliderToken`, `AsyncImageToken`
- Supporting types: `A11y`, `Padding`, `Margin`, `Background`, `Action`, `ColorValue`
- Enums: `Role`, `ActionType`, `TextStyle`, `ContentScale`, etc.

**Schema Validation**:
- Protocol buffer compiler validates message structure
- Required fields enforced at compile time
- Type safety guaranteed by protobuf

### 2. Kotlin Data Models (`shared-models/src/commonMain/kotlin/com/baksha97/sdui/shared/models/Models.kt`)

Hand-written Kotlin serializable data classes that mirror the protobuf schema.

**Key Features**:
- `@Serializable` annotations for JSON serialization
- Sealed interfaces for type safety (`Token`, `ContainerToken`, `InteractiveToken`)
- Default values and nullable properties for flexibility
- `TokenRegistry` class with comprehensive validation

**Validation Capabilities**:
```kotlin
// Screen payload validation
fun validateScreenPayload(screenPayload: ScreenPayload): List<String>

// Registry validation
fun validateRegistry(): List<String>

// Registration with validation
fun registerWithValidation(token: Token)
```

### 3. DSL Builder Schema (`shared-models/src/commonMain/kotlin/com/baksha97/sdui/shared/models/DSL.kt`)

Fluent builder API for programmatic UI construction.

**Key Components**:
- Builder interfaces: `TokenBuilder<T>`, `BaseBuilderProperties`
- Support interfaces: `PaddingSupport`, `MarginSupport`, `BackgroundSupport`, etc.
- Builder classes for each token type: `ColumnBuilder`, `TextBuilder`, etc.
- DSL functions: `column()`, `text()`, `button()`, etc.

**Usage Example**:
```kotlin
val ui = column("main") {
    text("title") {
        text = TemplateString("Hello World")
        style = TextStyle.HeadlineLarge
    }

    button("action") {
        text = TemplateString("Click me")
        onClick {
            type = ActionType.Navigate
            data("target" to "next_screen")
        }
    }
}
```

### 4. Generated Protocol Buffer Models (`proto-models/`)

Auto-generated Kotlin classes from the protobuf schema.

**Location**: `proto-models/src/commonMain/kotlin/com/baksha97/sdui/schema/`

**Purpose**:
- Provides protobuf-compatible serialization
- Ensures schema consistency between protobuf and Kotlin
- Used for network communication and persistence

### 5. JSON Schema (Generated by DSL CLI)

JSON Schema definitions for external validation and documentation.

**Generation Command**:
```bash
dsl-cli schema token-schema.json
```

**Features**:
- Complete JSON Schema for all token types
- Property descriptions and constraints
- Enum value definitions
- Required field specifications

**Example Schema Fragment**:
```json
{
  "type": "object",
  "title": "TextToken",
  "description": "A text component",
  "properties": {
    "text": {
      "$ref": "#/definitions/TemplateString",
      "description": "Text content"
    },
    "style": {
      "type": "string",
      "enum": ["DisplayLarge", "DisplayMedium", "BodyMedium"],
      "description": "Text style"
    }
  },
  "required": ["text"]
}
```

### 6. Component Registration Schema (Annotation Processing)

Annotation-based system for component registration and management.

**Key Annotations**:
- `@ComponentRegistry` - Marks a class as a component registry
- `@RegisterComponent` - Marks a method as providing a component

**Example**:
```kotlin
@ComponentRegistry(name = "MyComponents")
class ComponentDefinitions {

    @RegisterComponent(id = "welcome_text", version = 1)
    fun welcomeText(): TextToken {
        return TextToken(
            id = "welcome_text",
            version = 1,
            text = TemplateString("Welcome!")
        )
    }
}
```

## Schema Validation and Reinforcement

### Current Validation Mechanisms

1. **Compile-time Validation**:
   - Protocol buffer schema validation
   - Kotlin type system enforcement
   - Annotation processing validation

2. **Runtime Validation**:
   - `TokenRegistry.validateScreenPayload()`
   - `TokenRegistry.validateRegistry()`
   - `TokenRegistry.registerWithValidation()`

3. **External Validation**:
   - JSON Schema validation for API payloads
   - DSL CLI validation commands

### Enhanced Schema Validation (Implemented)

The TokenRegistry now includes comprehensive validation for token properties:

1. **Color Value Validation**:
   - RGB values must be in range 0-255
   - Alpha values must be in range 0-255
   - Validates all ColorValue properties across all tokens

2. **Content Validation**:
   - Text tokens must have non-empty text content
   - Button tokens must have non-empty text content
   - AsyncImage tokens must have non-empty URLs
   - Accessibility labels must be non-empty when provided

3. **Numeric Property Validation**:
   - Dimensions (width, height) must be positive
   - Slider initial values must be within specified range
   - Slider value ranges must be valid (start < end)
   - Slider steps must be positive
   - Layout weights must be non-negative

4. **Action Data Validation**:
   - Navigate actions require 'target' data field
   - DeepLink actions require 'url' data field
   - OpenUrl actions require 'url' data field
   - Custom actions allow any data (no validation)

5. **Version Validation**:
   - Token versions must be positive integers

**Usage Example**:
```kotlin
val registry = TokenRegistry()

// This will throw validation errors for invalid properties
val errors = registry.validateRegistry()
errors.forEach { println("Validation error: $it") }

// Register with immediate validation
try {
    registry.registerWithValidation(token)
} catch (e: IllegalArgumentException) {
    println("Invalid token: ${e.message}")
}
```

### Additional Schema Reinforcement Opportunities

1. **Template String Syntax Validation**:
   - Validate template variable syntax ({{variable}})
   - Check for unclosed template variables
   - Validate variable names

2. **Schema Synchronization**:
   - Automated tests to ensure schema consistency
   - Code generation to keep schemas in sync
   - Version compatibility checks

3. **Documentation Generation**:
   - Auto-generate schema documentation
   - API documentation from schemas
   - Interactive schema explorer

## Schema Evolution and Versioning

### Versioning Strategy

Each token has a `version` field for schema evolution:

```kotlin
sealed interface Token {
    val id: String
    val version: Int
    val a11y: A11y?
}
```

### Migration Support

The system supports schema migrations:

```kotlin
fun migrateTextToken(token: TextToken, targetVersion: Int): TextToken {
    return when (targetVersion) {
        1 -> token
        2 -> token.copy(/* migration logic */)
        else -> throw UnsupportedOperationException("Unsupported version: $targetVersion")
    }
}
```

### Best Practices

1. **Additive Changes**: Prefer adding optional fields over breaking changes
2. **Version Bumping**: Increment version for any schema change
3. **Backward Compatibility**: Maintain support for older versions
4. **Migration Testing**: Test all migration paths thoroughly

## Schema Usage Patterns

### Server-Side Usage

```kotlin
// Create screen payload
val screenPayload = screenPayload("home_screen") {
    tokenRef("header_section")
    tokenRef("content_section") {
        bind("title" to "Welcome")
        bind("subtitle" to "Get started")
    }
}

// Validate before sending
val errors = registry.validateScreenPayload(screenPayload)
if (errors.isNotEmpty()) {
    throw ValidationException("Invalid screen payload: $errors")
}
```

### Client-Side Usage

```kotlin
// Register components
val registry = TokenRegistry().apply {
    registerWithValidation(headerComponent)
    registerWithValidation(contentComponent)
}

// Validate registry
val errors = registry.validateRegistry()
if (errors.isNotEmpty()) {
    logger.error("Registry validation failed: $errors")
}

// Render screen
val screenPayload = api.getScreen("home_screen")
val ui = renderer.render(screenPayload, registry)
```

## Tools and Utilities

### DSL CLI Commands

```bash
# Generate JSON schema
dsl-cli schema output.json

# Validate component
dsl-cli validate component.json

# Generate component
dsl-cli generate profile-card output.json

# Migrate component
dsl-cli migrate input.json output.json 2
```

### Validation Utilities

```kotlin
// Registry validation
val stats = registry.getRegistrationStats()
println("Total tokens: ${stats["totalTokens"]}")

// Screen validation
val missingTokens = registry.validateScreenPayload(screenPayload)
if (missingTokens.isNotEmpty()) {
    logger.warn("Missing tokens: $missingTokens")
}
```

## Conclusion

The SDUI schema system provides multiple layers of validation and type safety. By understanding and properly utilizing these schemas, developers can build robust, maintainable server-driven UI applications with confidence in their data integrity and type safety.

For more information on specific schema components, refer to the individual documentation files and code comments in the respective modules.
