package com.baksha97.sdui.processor

import com.google.devtools.ksp.processing.*
import com.google.devtools.ksp.symbol.*
import com.google.devtools.ksp.validate

class ComponentRegistrationProcessor(
    private val codeGenerator: CodeGenerator,
    private val logger: KSPLogger
) : SymbolProcessor {

    override fun process(resolver: Resolver): List<KSAnnotated> {
        val componentRegistrySymbol = resolver.getSymbolsWithAnnotation("com.baksha97.sdui.shared.models.annotations.ComponentRegistry")
        val registerComponentSymbol = resolver.getSymbolsWithAnnotation("com.baksha97.sdui.shared.models.annotations.RegisterComponent")
        val registerScreenSymbol = resolver.getSymbolsWithAnnotation("com.baksha97.sdui.shared.models.annotations.RegisterScreen")

        val unableToProcess = mutableListOf<KSAnnotated>()

        // Process ComponentRegistry classes
        componentRegistrySymbol
            .filterIsInstance<KSClassDeclaration>()
            .forEach { classDeclaration ->
                if (!classDeclaration.validate()) {
                    unableToProcess.add(classDeclaration)
                    return@forEach
                }
                processComponentRegistry(classDeclaration, resolver)
            }

        return unableToProcess
    }

    private fun processComponentRegistry(classDeclaration: KSClassDeclaration, resolver: Resolver) {
        val annotation = classDeclaration.annotations.first { 
            it.shortName.asString() == "ComponentRegistry" 
        }

        val registryName = annotation.arguments.find { it.name?.asString() == "name" }?.value as? String 
            ?: "GeneratedComponentRegistry"

        val packageName = classDeclaration.packageName.asString()

        // Find all RegisterComponent functions in this class
        val componentFunctions = classDeclaration.getAllFunctions()
            .filter { function ->
                function.annotations.any { it.shortName.asString() == "RegisterComponent" }
            }
            .toList()

        // Find all RegisterScreen functions in this class
        val screenFunctions = classDeclaration.getAllFunctions()
            .filter { function ->
                function.annotations.any { it.shortName.asString() == "RegisterScreen" }
            }
            .toList()

        generateRegistryClass(packageName, registryName, componentFunctions, screenFunctions)
    }

    private fun generateRegistryClass(
        packageName: String,
        registryName: String,
        componentFunctions: List<KSFunctionDeclaration>,
        screenFunctions: List<KSFunctionDeclaration>
    ) {
        val file = codeGenerator.createNewFile(
            Dependencies(false),
            packageName,
            registryName
        )

        file.use { outputStream ->
            outputStream.write(generateRegistryCode(packageName, registryName, componentFunctions, screenFunctions))
        }
    }

    private fun generateRegistryCode(
        packageName: String,
        registryName: String,
        componentFunctions: List<KSFunctionDeclaration>,
        screenFunctions: List<KSFunctionDeclaration>
    ): ByteArray {
        val code = buildString {
            appendLine("package $packageName")
            appendLine()
            appendLine("import com.baksha97.sdui.shared.models.*")
            appendLine()
            appendLine("/**")
            appendLine(" * Auto-generated component registry.")
            appendLine(" * This class is generated by the ComponentRegistrationProcessor.")
            appendLine(" */")
            appendLine("class $registryName {")
            appendLine()
            appendLine("    /**")
            appendLine("     * Register all components in the provided registry.")
            appendLine("     */")
            appendLine("    fun registerComponents(registry: TokenRegistry) {")

            // Sort components by dependencies to ensure proper registration order
            val sortedComponents = sortComponentsByDependencies(componentFunctions)

            sortedComponents.forEach { function ->
                val annotation = function.annotations.first { it.shortName.asString() == "RegisterComponent" }
                val componentId = getComponentId(annotation, function)

                appendLine("        // Register component: $componentId")
                appendLine("        registry.register(${function.simpleName.asString()}())")
            }

            appendLine("    }")
            appendLine()

            if (screenFunctions.isNotEmpty()) {
                appendLine("    /**")
                appendLine("     * Get all screen payloads.")
                appendLine("     */")
                appendLine("    fun getScreens(): Map<String, ScreenPayload> {")
                appendLine("        return mapOf(")

                screenFunctions.forEach { function ->
                    val annotation = function.annotations.first { it.shortName.asString() == "RegisterScreen" }
                    val screenId = annotation.arguments.find { it.name?.asString() == "id" }?.value as? String ?: ""

                    appendLine("            \"$screenId\" to ${function.simpleName.asString()}(),")
                }

                appendLine("        )")
                appendLine("    }")
            }

            appendLine("}")
        }

        return code.toByteArray()
    }

    private fun getComponentId(annotation: KSAnnotation, function: KSFunctionDeclaration): String {
        val idFromAnnotation = annotation.arguments.find { it.name?.asString() == "id" }?.value as? String
        return if (idFromAnnotation.isNullOrEmpty()) {
            function.simpleName.asString()
        } else {
            idFromAnnotation
        }
    }

    private fun sortComponentsByDependencies(functions: List<KSFunctionDeclaration>): List<KSFunctionDeclaration> {
        val dependencyMap = mutableMapOf<String, List<String>>()
        val functionMap = mutableMapOf<String, KSFunctionDeclaration>()

        // Build dependency map
        functions.forEach { function ->
            val annotation = function.annotations.first { it.shortName.asString() == "RegisterComponent" }
            val componentId = getComponentId(annotation, function)
            val dependencies = annotation.arguments.find { it.name?.asString() == "dependencies" }?.value as? List<*>

            functionMap[componentId] = function
            dependencyMap[componentId] = dependencies?.mapNotNull { it as? String } ?: emptyList()
        }

        // Topological sort
        val result = mutableListOf<KSFunctionDeclaration>()
        val visited = mutableSetOf<String>()
        val visiting = mutableSetOf<String>()

        fun visit(componentId: String) {
            if (componentId in visiting) {
                logger.warn("Circular dependency detected for component: $componentId")
                return
            }
            if (componentId in visited) return

            visiting.add(componentId)
            dependencyMap[componentId]?.forEach { dependency ->
                if (dependency in functionMap) {
                    visit(dependency)
                }
            }
            visiting.remove(componentId)
            visited.add(componentId)

            functionMap[componentId]?.let { result.add(it) }
        }

        functionMap.keys.forEach { componentId ->
            if (componentId !in visited) {
                visit(componentId)
            }
        }

        return result
    }
}

class ComponentRegistrationProcessorProvider : SymbolProcessorProvider {
    override fun create(environment: SymbolProcessorEnvironment): SymbolProcessor {
        return ComponentRegistrationProcessor(environment.codeGenerator, environment.logger)
    }
}
