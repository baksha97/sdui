package com.baksha97.sdui

import com.baksha97.sdui.shared.models.SpecProvider
import com.baksha97.sdui.shared.models.ScreenPayload as SharedScreenPayload
import com.baksha97.sdui.shared.models.TokenRegistry as SharedTokenRegistry

/**
 * Implementation of SpecProvider that uses annotation-based component registration.
 * This demonstrates a more ergonomic approach to component registration.
 */
class AnnotationBasedSpecProvider : SpecProvider {
    
    private val autoRegistry = AutoGeneratedComponentRegistry()
    
    internal val sharedRegistry = SharedTokenRegistry().apply {
        // Use the auto-generated registry to register all components
        autoRegistry.registerComponents(this)
    }
    
    internal val screens = autoRegistry.getScreens()
    
    /**
     * Validate that all components are properly registered
     * This method is called automatically during initialization to guarantee component registration
     */
    private fun validateRegistration() {
        // Validate the registry itself
        val registryErrors = sharedRegistry.validateRegistry()
        if (registryErrors.isNotEmpty()) {
            val errorMessage = "Registry validation failed:\n${registryErrors.joinToString("\n")}"
            throw IllegalStateException(errorMessage)
        }

        // Validate all screens
        screens.values.forEach { screen ->
            val missingTokens = sharedRegistry.validateScreenPayload(screen)
            if (missingTokens.isNotEmpty()) {
                val errorMessage = "Screen '${screen.id}' references missing tokens: ${missingTokens.joinToString(", ")}"
                throw IllegalStateException(errorMessage)
            }
        }

        // Log successful validation
        val stats = sharedRegistry.getRegistrationStats()
        println("Annotation-based component registration validation successful:")
        println("  Total tokens: ${stats["totalTokens"]}")
        println("  Token types: ${stats["tokensByType"]}")
        println("  Screens validated: ${screens.size}")
    }

    /**
     * Get validation report for debugging purposes
     * @return Map containing validation information
     */
    fun getValidationReport(): Map<String, Any> {
        val registryErrors = sharedRegistry.validateRegistry()
        val screenValidation = screens.mapValues { (_, screen) ->
            sharedRegistry.validateScreenPayload(screen)
        }

        return mapOf(
            "registryErrors" to registryErrors,
            "screenValidation" to screenValidation,
            "registrationStats" to sharedRegistry.getRegistrationStats(),
            "isValid" to (registryErrors.isEmpty() && screenValidation.values.all { it.isEmpty() })
        )
    }

    // Initialize validation after all properties are created
    init {
        validateRegistration()
    }

    override suspend fun getScreen(id: String): SharedScreenPayload? {
        return screens[id]
    }

    override suspend fun getRegistry(): SharedTokenRegistry {
        return sharedRegistry
    }
}

/**
 * Comparison class showing the benefits of annotation-based registration.
 * This demonstrates how much more concise and maintainable the annotation approach is.
 */
object RegistrationComparison {
    
    /**
     * Manual registration approach (current):
     * - Verbose and error-prone
     * - Easy to forget to register child components
     * - Manual dependency ordering required
     * - Lots of boilerplate code
     */
    fun manualRegistrationExample() {
        val registry = SharedTokenRegistry()
        
        // Must manually create and register each component
        val title = com.baksha97.sdui.shared.models.TextToken(
            id = "card.title",
            version = 1,
            text = com.baksha97.sdui.shared.models.TemplateString("{{title}}")
        )
        val description = com.baksha97.sdui.shared.models.TextToken(
            id = "card.description",
            version = 1,
            text = com.baksha97.sdui.shared.models.TemplateString("{{description}}")
        )
        val button = com.baksha97.sdui.shared.models.ButtonToken(
            id = "card.button",
            version = 1,
            text = com.baksha97.sdui.shared.models.TemplateString("{{buttonText}}"),
            onClick = com.baksha97.sdui.shared.models.Action(
                type = com.baksha97.sdui.shared.models.ActionType.Custom,
                data = mapOf("action" to "click")
            )
        )
        
        // Must register in correct order
        registry.register(title)
        registry.register(description)
        registry.register(button)
        
        val card = com.baksha97.sdui.shared.models.CardToken(
            id = "card",
            version = 1,
            children = listOf(title, description, button)
        )
        registry.register(card)
    }
    
    /**
     * Annotation-based registration approach (proposed):
     * - Concise and declarative
     * - Automatic dependency resolution
     * - Compile-time validation
     * - Less boilerplate code
     * - Clear component definitions
     */
    fun annotationBasedRegistrationExample() {
        // Components are defined with annotations
        // Registration happens automatically
        // Dependencies are resolved automatically
        // Validation happens at compile time
        
        val provider = AnnotationBasedSpecProvider()
        // All components are automatically registered and validated!
    }
}